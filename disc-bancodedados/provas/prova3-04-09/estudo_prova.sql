CREATE OR REPLACE FUNCTION FDataAtual(nomeCidade IN VARCHAR2) RETURN VARCHAR2 IS	dia VARCHAR2(2);	mes VARCHAR2(2);	ano VARCHAR2(4);	nome_mes VARCHAR2(12);BEGIN	dia := TO_CHAR(SYSDATE, 'dd');	mes := TO_CHAR(SYSDATE, 'mm');	ano := TO_CHAR(SYSDATE, 'yyyy');		CASE (mes)		WHEN 1 THEN nome_mes := 'Janeiro';		WHEN 2 THEN nome_mes := 'Fevereiro';		WHEN 3 THEN nome_mes := 'Março';		WHEN 4 THEN nome_mes := 'Abril';		WHEN 5 THEN nome_mes := 'Maio';		WHEN 6 THEN nome_mes := 'Junho';		WHEN 7 THEN nome_mes := 'Julho';		WHEN 8 THEN nome_mes := 'Agosto';		WHEN 9 THEN nome_mes := 'Setembro';		WHEN 10 THEN nome_mes := 'Outubro';		WHEN 11 THEN nome_mes := 'Novembro';		WHEN 12 THEN nome_mes := 'Dezembro';	END CASE;	RETURN nomeCidade||', '||dia||' de '||nome_mes||' de '||ano;END;/CREATE OR REPLACE FUNCTION ParImpar(valor IN NUMBER) RETURN VARCHAR2 IS	resposta VARCHAR2(5);BEGIN	resposta := 'Impar';	IF MOD(valor, 2) = 0 THEN		resposta := 'Par';	END IF;	RETURN resposta;END;/CREATE OR REPLACE PROCEDURE FaixaNumeros(inicio IN NUMBER, final IN NUMBER) AS	i NUMBER(5);BEGIN	FOR i IN inicio..final LOOP		Dbms_output.put_line(i);	END LOOP;END;/CREATE OR REPLACE PROCEDURE sss(_start IN NUMBER, stop IN NUMBER, step IN NUMBER) AS	i NUMBER(5);BEGIN	EXCEPTION		WHEN _start > stop THEN			Dbms_output.put_line('STOP deve ser maior do que START!');			EXIT;	i := _start;	WHILE(i < stop) LOOP		Dbms_output.put_line(i);		i := i + step;	END LOOP;	END;/CREATE OR REPLACE FUNCTION TotalCarac(texto IN VARCHAR, car IN VARCHAR2) RETURN NUMBER IS	i NUMBER(5);	total NUMBER(8);BEGIN	total := 0;	FOR i IN 1..LENGTH(texto) LOOP		IF(UPPER(SUBSTR(texto, i, 1))=UPPER(car)) THEN			total := total + 1;		END IF;	END LOOP;	RETURN total;END;/CREATE OR REPLACE FUNCTION FATORIAL(valor IN NUMBER) RETURN NUMBER IS BEGIN	IF (valor = 0) THEN		RETURN 1;	ELSE 		RETURN valor * FATORIAL(valor - 1);	END IF;END;/CREATE OR REPLACE FUNCTION FATORIAL2(valor IN NUMBER) RETURN NUMBER IS	resultado NUMBER(12);	i NUMBER(3);BEGIN	resultado := 1;	i := 1;	IF (valor>=0) AND (valor<=15) THEN		WHILE (i <= valor) LOOP			resultado := resultado * i;			i := i + 1;		END LOOP;		RETURN resultado;	ELSE		RETURN NULL;	END IF;END;/CREATE OR REPLACE PROCEDURE INSERIRALUNOS(nomealuno IN VARCHAR2) ASBEGIN	INSERT INTO alunos(matricula, nome)	VALUES(seq_matricula.nextval, nomealuno);END; /CREATE OR REPLACE PROCEDURE CONSULTA(m IN NUMBER) AS	n VARCHAR2(45);BEGIN	SELECT nome INTO n FROM alunos WHERE matricula=m;	Dbms_output.put_line('Nome: '||n);	EXCEPTION		WHEN NO_DATA_FOUND THEN			Dbms_output.put_line('Aluno na cadastrado para o ID');END;/CREATE OR REPLACE PACKAGE ExerciciosSlides2 AS 	PROCEDURE FormatarNomeAutor(nome IN VARCHAR2);	FUNCTION EstatisticaVogal(palavra IN VARCHAR2) RETURN VARCHAR2;	FUNCTION Formula(n IN NUMBER) RETURN NUMBER;END;/CREATE OR REPLACE PACKAGE BODY ExerciciosSlides2 AS	PROCEDURE FormatarNomeAutor(nome IN VARCHAR2) AS		i NUMBER(5);		p NUMBER(5);		u NUMBER(5);		primeiro VARCHAR2(50);		ultimo VARCHAR2(50);	BEGIN		p := 0;		u := 0;		FOR i IN 1..LENGTH(nome) LOOP			IF (p = 0) AND (SUBSTR(nome, i, 1) = ' ') THEN				p := i - 1;			END IF;			IF (SUBSTR(nome, i, 1) = ' ') THEN				u := i + 1;			END IF;		END LOOP;		primeiro := SUBSTR(nome, 0, p);		ultimo := SUBSTR(nome, u, LENGTH(nome));		Dbms_output.put_line(ultimo||', '||primeiro);	END;		FUNCTION EstatisticaVogal(palavra IN VARCHAR2) RETURN VARCHAR2 IS		i NUMBER(5);		total_cons NUMBER(5);		total_voga NUMBER(5);		total_spac NUMBER(5);		perc_cons NUMBER(5,2);		perc_voga NUMBER(5,2);		perc_spac NUMBER(5,2);	BEGIN 		total_voga := 0;		total_cons := 0;		total_spac := 0;		FOR i IN 1..LENGTH(palavra) LOOP			IF (UPPER(SUBSTR(palavra, i, 1)) IN ('A', 'E', 'I', 'O', 'U')) THEN				total_voga := total_voga + 1;			END IF;			IF (UPPER(SUBSTR(palavra, i, 1)) = ' ') THEN				total_spac := total_spac + 1;			END IF;		END LOOP;		total_cons := LENGTH(palavra) - (total_voga + total_spac);		perc_voga := (total_voga*100) / LENGTH(palavra);		perc_cons := (total_cons*100) / LENGTH(palavra);		perc_spac := (total_spac*100) / LENGTH(palavra);		RETURN 'Vogais: '||perc_voga||'%, Consoantes: '||perc_cons||'%, Espacos: '||perc_spac||'%';	END;		FUNCTION Formula(n IN NUMBER) RETURN NUMBER IS		H NUMBER(5,2);	BEGIN		H = 0;		FOR i IN 1..n LOOP			H = H + (N + 1/N)		END LOOP;		RETURN H;	END;END;/CREATE OR REPLACE PROCEDURE Preencher(PTotal IN NUMBER) AS	aux NUMBER(10);BEGIN	aux:=0;	SELECT Nvl(Max(v.id),0) INTO aux FROM valores v;	FOR i IN 1..PTotal LOOP		aux:=aux+1;		INSERT INTO valores(id,valor1,valor2,valor3) VALUES		(aux,trunc(dbms_random.value(1,10)),trunc(dbms_random.value(1,10)),trunc(dbms_random.value(1,10)));	END LOOP;END;CREATE OR REPLACE PROCEDURE Preencher(PTotal IN NUMBER) AS 	aux NUMBER(10);BEGIN 	aux := 0;	SELECT NVL(MAX(v.id),0) INTO aux FROM valores v;	FOR i IN 1..PTotal LOOP			aux := aux + 1;		INSERT INTO valores(id, valor1, valor2, valor3) VALUES		(aux, TRUNC(dbms_random.value(1,10)),			  TRUNC(dbms_random.value(1,10)),			  TRUNC(dbms_random.value(1,10)));END;-- Função para retornar o total de vendas realizadas-- parametrizada pelo ID do cliente.CREATE OR REPLACE FUNCTION totalVendas(codigo IN NUMBER) IS		total NUMBER(10);BEGIN 	SELECT COUNT(*) TOTAL INTO total	FROM clientes cl, vendas vd 	WHERE cl.idcliente=vd.idcliente AND cl.idcliente=codigo;	RETURN total;END;/-- Procedimento para exibir as vendas por estado, o estado-- deverá ser informado via parâmetro.CREATE OR REPLACE PROCEDURE totalVendasEstado(uf IN VARCHAR2) AS	total NUMBER(10);BEGIN	SELECT COUNT(*) TOTAL_VENDAS INTO total	FROM clientes cl, vendas vd, estados es, cidades ci	WHERE vd.idcliente=cl.idcliente AND 	cl.idcidade=ci.idcidade AND ci.idestado=es.idestado	AND es.sigla='CE';	Dbms_output.put_line('Total: '||total);END;/-- Função para retornar o primeiro nome de uma pessoa-- informada via parâmetro, utilize o espaço em branco como-- referência.CREATE OR REPLACE FUNCTION primeiroNome(nome IN VARCHAR2) RETURN VARCHAR2 IS	p NUMBER(5);	primeiro VARCHAR2(40);BEGIN	p := 0;	FOR i IN 1..LENGTH(nome) LOOP 		IF (SUBSTR(nome, i, 1) = ' ') AND (p = 0) THEN			p := i - 1;			EXIT;		END IF;	END LOOP;	primeiro := SUBSTR(nome, 0, p);	RETURN primeiro;END;/CREATE OR REPLACE PACKAGE DBMS_PesquisasCar AS	FUNCTION p_espacos(str IN VARCHAR2) RETURN NUMBER;	FUNCTION p_inverter(str IN VARCHAR2) RETURN VARCHAR2;	FUNCTION p_pesquisa(str IN VARCHAR2, car IN CHAR) RETURN NUMBER;	FUNCTION p_substituir(str IN VARCHAR2,car1 IN CHAR,car2 IN char) RETURN VARCHAR2;END DBMS_PesquisasCar;/CREATE OR REPLACE PACKAGE BODY DBMS_PesquisasCar AS 	FUNCTION p_espacos(str IN VARCHAR2) RETURN NUMBER IS		t NUMBER(5);	BEGIN		t := 0;		FOR i IN 1..LENGTH(str) LOOP			IF (SUBSTR(str, i, 1) = ' ') THEN				t := t + 1;			END IF;		END LOOP;		RETURN t;	END;		FUNCTION p_inverter(str IN VARCHAR2) RETURN VARCHAR2 IS		newstr VARCHAR2(100);	BEGIN		newstr := '';		FOR i IN REVERSE 1..LENGTH(str) LOOP			newstr := newstr || SUBSTR(str, i, 1);		END LOOP;		RETURN newstr;	END;		FUNCTION p_pesquisa(str IN VARCHAR2, car IN CHAR) RETURN NUMBER IS 		t NUMBER(10);	BEGIN		t := 0;		FOR i IN 1..LENGTH(str) LOOP			IF (UPPER(SUBSTR(str, i, 1)) = UPPER(car)) THEN				t := t + 1;			END IF;		END LOOP;		RETURN t;	END;		FUNCTION p_substituir(str IN VARCHAR2, car1 IN CHAR, car2 IN CHAR) RETURN VARCHAR2 IS		newstr VARCHAR2(100);	BEGIN		newstr := '';		FOR i IN 1..LENGTH(str) LOOP			IF (SUBSTR(str, i, 1) = car1) THEN				newstr := newstr || car2;			ELSE				newstr := newstr || SUBSTR(str, i, 1);			END IF;		END LOOP;		RETURN newstr;	END;END DBMS_PesquisasCar;/CREATE OR REPLACE TRIGGER TI_VendasAFTER INSERTON Vendas REFERENCING NEW AS NFOR EACH ROW BEGIN	INSERT INTO vendas_dup(idvenda,idproduto,idcliente,idvendedor, quantidade,datavenda)	VALUES(:N.idvenda,:N.idproduto,:N.idcliente,:N.idvendedor,:N.quantidade,:N.datavenda);END;-- EXERCICIOSCREATE OR REPLACE PACKAGE DBMS_EXERCICIOS AS 	FUNCTION QTDLIVROSEMPRESTADOS(cliente IN NUMBER) RETURN NUMBER;	PROCEDURE QTDVENDIDADIARIAMENTE(mes IN VARCHAR2, ano IN VARCHAR2);	PROCEDURE CONSULTAVENDEDORES;	FUNCTION CLIENTERANDOM RETURN VARCHAR2;	PROCEDURE EXPORTARCLIENTES(p_profissao IN VARCHAR2);	PROCEDURE EXPORTAREDITORAS(p_cidade IN VARCHAR2);END DBMS_EXERCICIOS;/CREATE OR REPLACE PACKAGE BODY DBMS_EXERCICIOS AS	FUNCTION QTDLIVROSEMPRESTADOS(cliente IN NUMBER) RETURN NUMBER IS 		t NUMBER(10);	BEGIN		SELECT COUNT(*) TOTAL INTO t		FROM EMPRESTIMOS E, CLIENTES C		WHERE C.IDCLIENTE=E.IDCLIENTE		AND C.IDCLIENTE=cliente;				RETURN t;	END;		PROCEDURE QTDVENDIDADIARIAMENTE(mes IN VARCHAR2, ano IN VARCHAR2) AS		CURSOR Dados IS		SELECT p.descricaoproduto, SUM(v.quantidade) qtd		FROM produtos p, vendas v		WHERE p.idproduto=v.idproduto		AND TO_CHAR(v.datavenda, 'MM')= mes		AND TO_CHAR(v.datavenda, 'YYYY')=ano		GROUP BY p.descricaoproduto		ORDER BY p.descricaoproduto;	BEGIN		FOR d IN Dados LOOP			Dbms_output.put_line('Descrição: '||d.descricaoproduto||' Total Vend: '||d.qtd);		END LOOP;	END;		PROCEDURE CONSULTAVENDEDORES AS		CURSOR AnoVendedor IS		SELECT DISTINCT TO_CHAR(v.nascimento, 'YYYY') ano		FROM vendedores v		ORDER BY ano;		CURSOR Vendedores(p_ano IN VARCHAR2) IS		SELECT ve.nomevendedor nome		FROM vendedores ve		WHERE TO_CHAR(ve.nascimento,'YYYY')=p_ano;	BEGIN		FOR a IN AnoVendedor LOOP			Dbms_output.put_line('ANO: ['||a.ano||']');			Dbms_output.put_line('Vendedores:');			FOR v IN vendedores(a.ano) LOOP 				Dbms_output.put_line('  ->'||v.nome);			END LOOP;		END LOOP;	END;		FUNCTION CLIENTERANDOM RETURN VARCHAR2 IS		inicio NUMBER(15);		fim NUMBER(15);		tot NUMBER(15);		nome VARCHAR2(60);	BEGIN 		SELECT COUNT(*) INTO tot FROM Clientes;		IF (tot=0) THEN			RETURN 'Nao ha registros para tabela clientes';		ELSE 			SELECT MIN(c.idcliente) INTO inicio FROM Clientes c;			SELECT MAX(ce.idcliente) INTO fim FROM Clientes ce;			WHILE (nome IS NULL) LOOP				SELECT cl.nomecliente INTO nome 				FROM Clientes cl 				WHERE cl.idcliente=TRUNC(Dbms_random.value(inicio, fim));			END LOOP;			RETURN nome;		END IF;	END;		PROCEDURE EXPORTARCLIENTES(p_profissao IN VARCHAR2) AS		CURSOR DadosClientes IS		SELECT ci.nomecidade, c.nomecliente,		c.nascimento,c.rendamensal		FROM clientes c, cidades ci, profissoes p		WHERE c.idcidade=ci.idcidade 		AND c.idprofissao=p.idprofissao		AND UPPER(p.descricaoprofissao)=UPPER(p_profissao);		arquivo utl_file.file_type;	BEGIN		arquivo := utl_file.fopen('DESTINO', 'Clientes.csv', 'W');		FOR dado IN DadosClientes LOOP			utl_file.put_line(arquivo, dado.nomecliente||';'||							           dado.nomecidade||';'||									   dado.nascimento||';'||									   dado.rendamensal);		END LOOP;		utl_file.fclose(arquivo);	END;		PROCEDURE EXPORTAREDITORAS(p_cidade IN VARCHAR2) AS		CURSOR DadosEditoras IS		SELECT e.nomeeditora, c.nomecidade		FROM editoras e, cidades c 		WHERE e.idcidade=c.idcidade		AND UPPER(c.nomecidade) LIKE UPPER(p_cidade)||'%'; 		arquivo utl_file.file_type;	BEGIN		arquivo := utl_file.fopen('DESTINO', 'Editoras.txt', 'W');		FOR dado IN DadosEditoras LOOP			utl_file.put_line(arquivo, 'Editora: '||dado.nomeeditora||' Cidade: '||dado.nomecidade);		END LOOP;		utl_file.fclose(arquivo);	END;END DBMS_EXERCICIOS;/CREATE OR REPLACE FUNCTION NOMEMAIUSCULO(p_string IN VARCHAR2) RETURN VARCHAR2 IS 	newstr VARCHAR2(80);BEGIN	newstr := newstr||UPPER(SUBSTR(p_string,1,1));	FOR i IN 2..LENGTH(p_string) LOOP		IF (SUBSTR(p_string, i-1, 1) = ' ') THEN			newstr := newstr||UPPER(SUBSTR(p_string, i, 1));		ELSE			newstr := newstr||LOWER(SUBSTR(p_string, i, 1));        END IF;	END LOOP;	RETURN newstr;END;/CREATE OR REPLACE TRIGGER TI_MaiuscNomeBEFORE INSERT OR UPDATE ON Clientes REFERENCING NEW AS NFOR EACH ROW BEGIN    :N.NOMECLIENTE := NOMEMAIUSCULO(:N.NOMECLIENTE);END;/CREATE OR REPLACE TRIGGER TI_UFBEFORE INSERT OR UPDATEON Estados REFERENCING NEW AS NFOR EACH ROW BEGIN	:N.sigla := UPPER(:N.sigla);END;/CREATE OR REPLACE TRIGGER TI_AutorNomeMaiusculoBEFORE INSERT OR DELETE ON Livros REFERENCING NEW AS NFOR EACH ROW BEGIN	:N.autor := NOMEMAIUSCULO(:N.autor);END;/